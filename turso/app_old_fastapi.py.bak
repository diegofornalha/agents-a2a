#!/usr/bin/env python3
"""
Agente A2A Turso - Gerenciamento de Persist√™ncia de Dados
Porta: 4243
"""

import os
import json
import uuid
import asyncio
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List
from contextlib import asynccontextmanager

from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
import libsql_experimental as libsql
from dotenv import load_dotenv
import httpx

# Carregar vari√°veis de ambiente
load_dotenv()

# Configura√ß√£o
PORT = int(os.getenv("PORT", 4243))
AGENT_ID = os.getenv("AGENT_ID", f"turso-agent-{uuid.uuid4()}")
AGENT_NAME = os.getenv("AGENT_NAME", "TursoAgent")
TURSO_DATABASE_URL = os.getenv("TURSO_DATABASE_URL", "file:local.db")
TURSO_AUTH_TOKEN = os.getenv("TURSO_AUTH_TOKEN", "")
A2A_DISCOVERY_URL = os.getenv("A2A_DISCOVERY_URL", "http://localhost:4240")

# Cliente Turso global
db_client = None

# Modelos Pydantic
class StoreRequest(BaseModel):
    agent_id: str
    key: str
    value: Any
    metadata: Optional[Dict[str, Any]] = None
    ttl: Optional[int] = None

class QueryRequest(BaseModel):
    sql: str
    args: Optional[List[Any]] = []

class SyncRequest(BaseModel):
    source_agent: str
    operation: str
    data: Dict[str, Any]

class BatchOperation(BaseModel):
    sql: str
    args: Optional[List[Any]] = []

class BatchRequest(BaseModel):
    operations: List[BatchOperation]

class SchemaRequest(BaseModel):
    table_name: str
    columns: List[Dict[str, str]]

# Metadados do agente
AGENT_METADATA = {
    "id": AGENT_ID,
    "name": AGENT_NAME,
    "type": "persistence",
    "version": "1.0.0",
    "capabilities": [
        "data-storage",
        "query-execution",
        "schema-management",
        "sync-memory",
        "batch-operations",
        "real-time-updates"
    ],
    "status": "active",
    "port": PORT,
    "endpoints": {
        "health": "/health",
        "discovery": "/discovery",
        "store": "/api/store",
        "retrieve": "/api/retrieve",
        "query": "/api/query",
        "sync": "/api/sync",
        "schema": "/api/schema",
        "batch": "/api/batch"
    }
}

# Agent Card para .well-known/agent.json
AGENT_CARD = {
    "name": "Turso Persistence Agent",
    "description": "Agent for data persistence and management using Turso Database",
    "url": f"http://localhost:{PORT}/",
    "version": "1.0.0",
    "defaultInputModes": ["json"],
    "defaultOutputModes": ["json"],
    "capabilities": {
        "streaming": False,
        "batch": True,
        "persistence": True
    },
    "skills": [
        {
            "id": "store_data",
            "name": "Store Data",
            "description": "Store key-value data with optional TTL",
            "tags": ["storage", "persistence", "database"],
            "examples": [
                "store campaign data",
                "save user preferences",
                "persist agent memory"
            ]
        },
        {
            "id": "retrieve_data",
            "name": "Retrieve Data",
            "description": "Retrieve stored data by agent ID and key",
            "tags": ["query", "fetch", "database"],
            "examples": [
                "get campaign data",
                "fetch user settings",
                "retrieve agent memory"
            ]
        },
        {
            "id": "execute_query",
            "name": "Execute SQL Query",
            "description": "Execute custom SQL queries (SELECT only)",
            "tags": ["sql", "query", "database"],
            "examples": [
                "select all campaigns",
                "count total records",
                "find expired data"
            ]
        },
        {
            "id": "sync_memory",
            "name": "Sync Memory",
            "description": "Synchronize memory with Claude Flow",
            "tags": ["sync", "memory", "claude-flow"],
            "examples": [
                "sync agent memories",
                "update shared context",
                "persist workflow state"
            ]
        }
    ],
    "supportsAuthenticatedExtendedCard": False
}

async def init_database():
    """Inicializar conex√£o com Turso e criar tabelas"""
    global db_client
    
    try:
        # Conectar ao Turso
        if TURSO_DATABASE_URL == "file:local.db" or not TURSO_AUTH_TOKEN:
            print("üóÑÔ∏è  Usando Turso local (SQLite)")
            db_client = libsql.connect("local.db", sync_url=None, auth_token=None)
        else:
            db_client = libsql.connect(
                "local.db",
                sync_url=TURSO_DATABASE_URL,
                auth_token=TURSO_AUTH_TOKEN
            )
        
        # Criar tabelas
        queries = [
            """CREATE TABLE IF NOT EXISTS agent_data (
                id TEXT PRIMARY KEY,
                agent_id TEXT NOT NULL,
                key TEXT NOT NULL,
                value TEXT NOT NULL,
                metadata TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                expires_at DATETIME,
                UNIQUE(agent_id, key)
            )""",
            
            """CREATE TABLE IF NOT EXISTS agent_memory (
                id TEXT PRIMARY KEY,
                agent_id TEXT NOT NULL,
                session_id TEXT,
                memory_type TEXT,
                content TEXT NOT NULL,
                embedding TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )""",
            
            """CREATE TABLE IF NOT EXISTS sync_logs (
                id TEXT PRIMARY KEY,
                source_agent TEXT NOT NULL,
                target_agent TEXT,
                operation TEXT NOT NULL,
                data TEXT,
                status TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )""",
            
            """CREATE TABLE IF NOT EXISTS prp_configs (
                id TEXT PRIMARY KEY,
                agent_id TEXT NOT NULL,
                config_type TEXT NOT NULL,
                config_data TEXT NOT NULL,
                version INTEGER DEFAULT 1,
                active BOOLEAN DEFAULT true,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )"""
        ]
        
        for query in queries:
            db_client.execute(query)
            db_client.commit()
        
        print("‚úÖ Banco de dados inicializado com sucesso")
        
    except Exception as e:
        print(f"‚ùå Erro ao inicializar banco de dados: {e}")
        raise

async def register_with_discovery():
    """Registrar agente no servi√ßo de discovery"""
    if not A2A_DISCOVERY_URL:
        return
    
    async with httpx.AsyncClient() as client:
        try:
            await client.post(
                f"{A2A_DISCOVERY_URL}/register",
                json={
                    **AGENT_METADATA,
                    "url": f"http://localhost:{PORT}"
                }
            )
            print("‚úÖ Agente registrado no discovery")
        except Exception as e:
            print(f"‚ö†Ô∏è  Erro ao registrar no discovery: {e}")

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Gerenciar ciclo de vida da aplica√ß√£o"""
    # Startup
    await init_database()
    
    # Registrar no discovery periodicamente
    async def periodic_registration():
        while True:
            await register_with_discovery()
            await asyncio.sleep(30)
    
    task = asyncio.create_task(periodic_registration())
    
    yield
    
    # Shutdown
    task.cancel()
    if db_client:
        db_client.close()

# Criar aplica√ß√£o FastAPI
app = FastAPI(
    title="Turso Agent",
    description="A2A Agent for data persistence with Turso Database",
    version="1.0.0",
    lifespan=lifespan
)

@app.get("/")
async def root():
    """Endpoint raiz"""
    return {
        "agent": AGENT_NAME,
        "version": "1.0.0",
        "status": "active",
        "endpoints": AGENT_METADATA["endpoints"]
    }

@app.get("/health")
async def health():
    """Health check"""
    return {
        "status": "active",
        "agent": AGENT_NAME,
        "uptime": datetime.now().isoformat(),
        "database": "connected" if db_client else "disconnected"
    }

@app.get("/discovery")
async def discovery():
    """Discovery endpoint para A2A"""
    return AGENT_METADATA

@app.get("/.well-known/agent.json")
async def agent_card():
    """Agent card para descoberta"""
    return AGENT_CARD

@app.post("/api/store")
async def store_data(request: StoreRequest):
    """Armazenar dados"""
    try:
        data_id = str(uuid.uuid4())
        expires_at = None
        
        if request.ttl:
            expires_at = (datetime.now() + timedelta(seconds=request.ttl)).isoformat()
        
        db_client.execute(
            """INSERT OR REPLACE INTO agent_data 
               (id, agent_id, key, value, metadata, expires_at, updated_at) 
               VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)""",
            [
                data_id,
                request.agent_id,
                request.key,
                json.dumps(request.value),
                json.dumps(request.metadata) if request.metadata else None,
                expires_at
            ]
        )
        db_client.commit()
        
        return {
            "success": True,
            "id": data_id,
            "message": "Dados armazenados com sucesso"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/retrieve/{agent_id}/{key}")
async def retrieve_data(agent_id: str, key: str):
    """Recuperar dados"""
    try:
        result = db_client.execute(
            """SELECT * FROM agent_data 
               WHERE agent_id = ? AND key = ? 
               AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)""",
            [agent_id, key]
        )
        
        rows = result.fetchall()
        if not rows:
            raise HTTPException(status_code=404, detail="Dados n√£o encontrados")
        
        row = rows[0]
        return {
            "id": row[0],
            "agent_id": row[1],
            "key": row[2],
            "value": json.loads(row[3]),
            "metadata": json.loads(row[4]) if row[4] else None,
            "created_at": row[5],
            "updated_at": row[6]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/query")
async def execute_query(request: QueryRequest):
    """Executar query SQL (somente SELECT)"""
    try:
        if not request.sql.strip().upper().startswith("SELECT"):
            raise HTTPException(
                status_code=403,
                detail="Apenas queries SELECT s√£o permitidas"
            )
        
        result = db_client.execute(request.sql, request.args)
        rows = result.fetchall()
        
        return {
            "rows": rows,
            "count": len(rows)
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/sync")
async def sync_data(request: SyncRequest):
    """Sincronizar com Claude Flow"""
    try:
        sync_id = str(uuid.uuid4())
        
        db_client.execute(
            """INSERT INTO sync_logs (id, source_agent, operation, data, status) 
               VALUES (?, ?, ?, ?, ?)""",
            [
                sync_id,
                request.source_agent,
                request.operation,
                json.dumps(request.data),
                "completed"
            ]
        )
        db_client.commit()
        
        return {
            "success": True,
            "sync_id": sync_id,
            "message": "Sincroniza√ß√£o realizada com sucesso"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/batch")
async def batch_operations(request: BatchRequest):
    """Executar opera√ß√µes em lote"""
    try:
        for op in request.operations:
            db_client.execute(op.sql, op.args or [])
        
        db_client.commit()
        
        return {
            "success": True,
            "count": len(request.operations),
            "message": "Opera√ß√µes em lote executadas com sucesso"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/schema")
async def manage_schema(request: SchemaRequest):
    """Gerenciar esquema do banco"""
    try:
        column_defs = ", ".join([
            f"{col['name']} {col['type']} {col.get('constraints', '')}"
            for col in request.columns
        ])
        
        sql = f"CREATE TABLE IF NOT EXISTS {request.table_name} ({column_defs})"
        db_client.execute(sql)
        db_client.commit()
        
        return {
            "success": True,
            "message": f"Tabela {request.table_name} criada/atualizada com sucesso"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    print(f"üöÄ Iniciando {AGENT_NAME} na porta {PORT}...")
    uvicorn.run(app, host="0.0.0.0", port=PORT)